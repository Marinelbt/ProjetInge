---
title: "Prédictions"
author: "Marine"
date: "2025-01-15"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

#importations

```{r}
library(readr)
library(dplyr)
library(tidyverse)
library(ggplot2)
library(RcmdrMisc)
library(GGally)
library(cvTools)
library(pROC)
library(caret)
library(rsample)
library(plotly)
```


#Jeu de données initial

```{r}
data <- read.csv("../data_final/df_pdfs_final.csv", header = TRUE, sep = ",")

data <- data %>%
  separate(score_final, into = c("score_final_r", "score_final_v"), sep = "-") %>%
  mutate(
    score_final_r = as.integer(score_final_r),
    score_final_v = as.integer(score_final_v)
  )

data_mod1 <- data %>%
  group_by(code_rencontre, club_recevant, coach_recevant, club_visiteur, coach_visiteur, journee, score_final_r, score_final_v, fichier) %>%
  summarise(temps_proche_59_min = max(Temps_Sec[Temps_Sec < 59 * 60], na.rm = TRUE),
            statut_59_min_r = first(statut_recevant[Temps_Sec == temps_proche_59_min]),
            statut_59_min_v = -statut_59_min_r,
            score_recevant_59_min = first(score_recevant[Temps_Sec == temps_proche_59_min]),
            score_visiteur_59_min = first(score_visiteur[Temps_Sec == temps_proche_59_min]),
            TM_derniere_min_r = if_else(
              any(Temps_Sec >= 59 * 60 & grepl("tem", action, ignore.case = TRUE) & action_equipe == "r"),
              1, 
              0
              ),
            TM_derniere_min_v = if_else(
              any(Temps_Sec >= 59 * 60 & grepl("tem", action, ignore.case = TRUE) & action_equipe == "v"),
              1, 
              0
              ),
            DM_r = if_else(
              any(Temps_Sec >= 57 * 60 & (grepl("2MN", action, ignore.case = TRUE) | grepl("Dis", action, ignore.case = TRUE)) & action_equipe == "r"),
              1, 
              0
              ),
            DM_v = if_else(
              any(Temps_Sec >= 57 * 60 & (grepl("2MN", action, ignore.case = TRUE) | grepl("Dis", action, ignore.case = TRUE)) & action_equipe == "v"),
              1, 
              0
              ),
            .groups = "drop"
            ) %>%
  filter(abs(score_recevant_59_min - score_visiteur_59_min) <= 3) %>% 
  pivot_longer(
    cols = c(statut_59_min_r, statut_59_min_v), 
    names_to = "equipe", 
    values_to = "statut_59_min"
  ) %>%
  mutate(
    equipe = case_when(
      equipe == "statut_59_min_r" ~ "R",
      equipe == "statut_59_min_v" ~ "V"
    ),
    statut_final = case_when(
      equipe == "R" & score_final_r > score_final_v ~ 1,
      equipe == "V" & score_final_v > score_final_r ~ 1,
      score_final_v == score_final_r ~ 0,
      equipe == "R" & score_final_r < score_final_v ~ -1,
      equipe == "V" & score_final_v < score_final_r ~ -1,
    ),
    effet_positif = case_when(
      statut_59_min == -1 & (statut_final == 0 | statut_final == 1) ~ 1,
      statut_59_min == 1 & statut_final == 1 ~ 1,
      statut_59_min == 0 & statut_final == 1 ~ 1,
      TRUE ~ 0
    ),
    TM_derniere_min = case_when(
      equipe == "R" & TM_derniere_min_r == 1 ~ 1,
      equipe == "V" & TM_derniere_min_v == 1 ~ 1,
      TRUE ~ 0
    ),
    TM_derniere_min_adverse = case_when(
      equipe == "V" & TM_derniere_min_r == 1 ~ 1,
      equipe == "R" & TM_derniere_min_v == 1 ~ 1,
      TRUE ~ 0
    ),
    HF = case_when(
      grepl("F", fichier) ~ "F",
      TRUE ~ "H"
    ),
     DM = case_when(
      equipe == "R" & DM_r == 1 ~ 1,
      equipe == "V" & DM_v == 1 ~ 1,
      TRUE ~ 0
    ),
    DM_adverse = case_when(
      equipe == "V" & DM_r == 1 ~ 1,
      equipe == "R" & DM_v == 1 ~ 1,
      TRUE ~ 0
    ),
    division = case_when(
      grepl("D1", fichier, ignore.case = TRUE) ~ "D1",
      grepl("D2", fichier, ignore.case = TRUE) ~ "D2",
      grepl("N1", fichier, ignore.case = TRUE) ~ "N1"
    ),
    saison = case_when(
      grepl("2021", fichier, ignore.case = TRUE) ~ "2021",
      grepl("2122", fichier, ignore.case = TRUE) ~ "2122",
      grepl("2223", fichier, ignore.case = TRUE) ~ "2223",
      grepl("2324", fichier, ignore.case = TRUE) ~ "2324",
      grepl("2425", fichier, ignore.case = TRUE) ~ "2425"
    )
  ) %>% 
  dplyr::select(-c(TM_derniere_min_r, TM_derniere_min_v, DM_r, DM_v, temps_proche_59_min)) %>% 
  ungroup()

# One ne garde que l'équipe recevante 
data_mod1 <- data_mod1 %>%
  filter(equipe == "R") %>% 
  filter(statut_59_min != 0 | statut_final != 0)
```


# Mise en facteur

```{r}
data_mod1$statut_59_min <- factor(data_mod1$statut_59_min)
data_mod1$statut_final <- factor(data_mod1$statut_final)
data_mod1$effet_positif <- factor(data_mod1$effet_positif)
data_mod1$TM_derniere_min <- factor(data_mod1$TM_derniere_min)
data_mod1$TM_derniere_min_adverse <- factor(data_mod1$TM_derniere_min_adverse)
data_mod1$HF <- factor(data_mod1$HF)
data_mod1$DM <- factor(data_mod1$DM)
data_mod1$DM_adverse <- factor(data_mod1$DM_adverse)
data_mod1$club_recevant <- factor(data_mod1$club_recevant)
data_mod1$saison <- factor(data_mod1$saison)
data_mod1$division <- factor(data_mod1$division)
```


# Ajout de la variable différence de point

```{r}
diff_norme <- read.csv("data_final/data_diff_norme_final.csv", row.names = 1)
diff_norme$saison <- factor(diff_norme$saison)

data_mod1 <- data_mod1 %>% 
  dplyr::select(-c("journee","division","HF","saison")) %>% 
  left_join(diff_norme, by = join_by(code_rencontre)) %>% 
  drop_na()
```

```{r}
data_mod1 %>% 
  ggplot(aes(x = diff_point_norm)) +
  geom_density() +
  theme_minimal()

quantiles <- quantile(data_mod1$diff_point_norm, probs = c(0, 1/3, 2/3, 1))

print(quantiles)

data_mod1$group_diff_point <- cut(data_mod1$diff_point_norm,
                                  breaks = quantiles,
                                  labels = c("moins fort","meme niveau","plus fort"),
                                  include.lowest = T)
table(data_mod1$group_diff_point)


ggplot(data_mod1, aes(x = group_diff_point, y = diff_point_norm, fill = group_diff_point)) +
  geom_boxplot() +
  labs(title = "Répartition des groupes créés", x = "Groupes", y = "Valeurs de A") +
  theme_minimal()

data_mod1 <- data_mod1 %>% 
  mutate(ecart_classement = case_when(
    group_diff_point == "moins fort" ~ -1,
    group_diff_point == "meme niveau" ~ 0,
    group_diff_point == "plus fort" ~ 1
  ))

data_mod1$ecart_classement <- as.factor(data_mod1$ecart_classement)

data_mod1 %>% 
  mutate(journee_num = as.numeric(str_extract(journee, "[0-9].*")) )%>% 
  ggplot(aes(x = journee_num, y = diff_point_norm, color = ecart_classement)) +
  geom_point(size = 2, alpha = 0.7) +  # Points bien alignés
  labs(title = "Nuage de points des différences de points par journée",
       x = "Journée",
       y = "Différence de points normée") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))

```

```{r}
#data_mod1 <- data_mod1[,-26]
```


# Sous-jeux de données 

```{r}
train_data <- data_mod1 %>% 
  filter(saison != "2425")

test_data <- data_mod1 %>% 
  filter(saison == "2425")
```

# régression logistique avec caret

```{r}
train_control <- trainControl(
  method = "cv",  
  number = 20 
)

set.seed(123)  
model <- train(
  effet_positif ~ TM_derniere_min + TM_derniere_min_adverse + DM_adverse + DM + ecart_classement + statut_59_min + HF,
  data = train_data,   
  method = "glm", 
  family = "binomial",
  trControl = train_control
)

print(model)
pred_prob <- predict(model, newdata = test_data, type = "prob")

# Créer une courbe ROC
roc_curve <- roc(test_data$effet_positif, pred_prob)
plot(roc_curve, print.auc = TRUE, legacy.axes = TRUE)

# Trouver le seuil optimal
optimal_threshold <- coords(roc_curve, "best", ret = "threshold")
print(paste("Seuil optimal:", optimal_threshold))

# Classifier en fonction du seuil optimal
pred_class <- ifelse(pred_prob > optimal_threshold, 1, 0)

# Calcul de l'accuracy et table de confusion
accuracy <- mean(test_data$effet_positif == pred_class)
confusion <- table(test_data$effet_positif, pred_class)

# Afficher les résultats
print("Table de confusion:")
print(confusion)
print(paste("Accuracy sur test_data:", accuracy))
```


# Random forest avec caret

```{r}
train_control <- trainControl(
  method = "cv",  
  number = 20 
)

set.seed(123)  
model_rf <- train(
  effet_positif ~ TM_derniere_min + TM_derniere_min_adverse + DM_adverse + DM + ecart_classement + statut_59_min + HF,
  data = train_data,   
  method = "rf", 
  family = "binomial",
  trControl = train_control
)

print(model_rf)

pred_prob <- predict(model_rf, type = "prob")

# Générer la courbe ROC et l'afficher
roc_curve <- roc(train_data$effet_positif, pred_prob[, "1"])
plot(roc_curve, print.auc = TRUE, legacy.axes = TRUE)

# Enregistrer le graphique au format PNG
png("Graphiques/graphique_pred.png", width = 1000, height = 1000, res = 300)
plot(roc_curve, print.auc = TRUE, legacy.axes = TRUE)
dev.off()

# Trouver le seuil optimal
optimal_threshold <- coords(roc_curve, "best", ret = "threshold")
print(paste("Seuil optimal:", optimal_threshold))

pred_class <- ifelse(pred_prob[, "1"] > optimal_threshold[1,1], 1, 0)

accuracy <- mean(train_data$effet_positif == pred_class)
confusion <- table(train_data$effet_positif, pred_class)
#auc <- auc(test_data$effet_positif, pred_prob)

print("Table de confusion:")
print(confusion)
print(paste("Accuracy sur test_data:", accuracy))
#print(paste("AUC sur test_data:", auc))


# Conversion de la table de confusion en data.frame
confusion_df <- as.data.frame(confusion)

# Affichage des colonnes pour vérifier les noms
print(colnames(confusion_df))

# Renommer les colonnes correctement (adaptez les noms si nécessaire)
colnames(confusion_df) <- c("Actual", "Predicted", "Count")

# Ajout des pourcentages et étiquettes
confusion_df <- confusion_df %>%
  group_by(Actual) %>%
  mutate(Percentage = Count / sum(Count) * 100) %>%
  ungroup() %>%
  mutate(Label = paste0(Count, "\n(", round(Percentage, 1), "%)"))

# Création du graphique
plot <- ggplot(confusion_df, aes(x = Predicted, y = Actual, fill = Count)) +
  geom_tile(color = "white") +
  geom_text(aes(label = Label), size = 4) +
  scale_fill_gradient(low = "lightblue1", high = "dodgerblue3") +
  labs(
    title = "Table de Prédiction",
    subtitle = paste("Accuracy:", round(sum(diag(confusion)) / sum(confusion), 3)),
    x = "Classe Prédite",
    y = "Classe Réelle",
    fill = "Nombre"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 16, face = "bold"),
    plot.subtitle = element_text(size = 14),
    axis.text = element_text(size = 12),
    axis.title = element_text(size = 14)
  )

plot

# Sauvegarde du graphique
ggsave("Graphiques/table_prediction.png", plot = plot, width = 5, height = 5, dpi = 300)
```

# LDA/QDA

```{r}
library(MASS)

# Modèle LDA
modele_lda <- qda(effet_positif ~ TM_derniere_min + TM_derniere_min_adverse + DM_adverse + DM + ecart_classement + statut_59_min + HF, 
                  data = train_data)

# Prédictions
predictions <- predict(modele_lda, newdata = test_data)$class
accuracy <- mean(test_data$effet_positif == predictions)
print(paste("Accuracy : ", accuracy))
```

# Test sur un match qui ne s'est pas necore produit 

```{r}

# Définir les valeurs possibles pour chaque colonne
TM_derniere_min <- c(0, 1)
TM_derniere_min_adverse <- c(0, 1)
DM_adverse <- c(0, 1)
DM <- c(0, 1)
statut_59_min <- c(-1, 0, 1)
ecart_classement <- c(1, 2, 3)
HF <- "F"

# Générer toutes les combinaisons possibles
df <- expand.grid(
  TM_derniere_min = TM_derniere_min,
  TM_derniere_min_adverse = TM_derniere_min_adverse,
  DM_adverse = DM_adverse,
  DM = DM,
  statut_59_min = statut_59_min,
  ecart_classement = ecart_classement,
  HF = HF
)

# Afficher le DataFrame
print(df)

#predictions 
pred_prob <- predict(model_rf, new_data = df, type = "prob")
pred_class <- ifelse(pred_prob[, "1"] > optimal_threshold[1,1], 1, 0)

# Créer une heatmap
ggplot(df, aes(x = TM_derniere_min, y = DM, fill = as.factor(prediction))) +
  geom_tile(color = "white") +
  scale_fill_viridis_d(name = "Prediction") +
  labs(title = "Heatmap des prédictions", x = "TM_derniere_min", y = "DM") +
  theme_minimal()

# Créer un graphique interactif
plot_ly(
  data = combinations,
  x = ~TM_derniere_min,
  y = ~DM_adverse,
  color = ~as.factor(prediction),
  colors = "Viridis",
  type = 'scatter',
  mode = 'markers',
  marker = list(size = 10)
) %>%
  layout(
    title = "Graphique interactif des prédictions",
    xaxis = list(title = "TM_derniere_min"),
    yaxis = list(title = "DM_adverse")
  )
```






